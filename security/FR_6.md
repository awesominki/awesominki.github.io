---
layout: page
title: 6. DB 복제 지연
description: >
hide_description: true
sitemap: false
---

### 6.1 복제 지연이란?

- **복제 지연**은 데이터가 쓰기 DB에서 읽기 DB로 복제되는 과정에서 발생하는 시간 지연을 의미합니다. 이 용어는 쓰기 작업이 발생한 후 그 변경 사항이 읽기 DB에 반영되기까지의 지연 시간을 설명하는 데 사용됩니다.
- 복제 지연으로 인해, 읽기 DB에서 최신 상태의 데이터를 읽지 못하고 이전 상태의 데이터를 읽게 되는 문제가 발생할 수 있습니다.
- 시스템에서는 일반적으로 다음과 같은 방식으로 데이터베이스를 운영합니다
    - **쓰기 DB**: 모든 쓰기 작업(데이터 삽입, 업데이트, 삭제 등)을 처리하는 데이터베이스입니다. 보통 마스터(master) 데이터베이스라고도 합니다.
    - **읽기 DB**: 읽기 작업만 처리하는 데이터베이스로, 보통 슬레이브(slave) 데이터베이스 또는 리플리카(replica)라고 합니다. 이 데이터베이스는 쓰기 DB에서 복제(replication)된 데이터를 사용합니디.

### 6.2 문제 발생 예시

- 쓰기와 읽기 DB가 분리된 시스템에서는 쓰기 작업이 일어난 후, 그 변경 내용이 읽기 DB로 복제되기까지 시간이 걸립니다. 이 지연으로 인해 다음과 같은 상황이 발생할 수 있습니다:
    1. **쓰기 작업**: 애플리케이션이 쓰기 DB에 새로운 데이터를 저장합니다.
    2. **지연**: 이 데이터는 복제 지연 때문에 즉시 읽기 DB에 반영되지 않습니다.
    3. **읽기 작업**: 쓰기 작업 직후에 애플리케이션이 읽기 DB에서 데이터를 조회하려고 합니다.
    4. **이전 데이터 조회**: 이 시점에서 읽기 DB는 아직 새로운 데이터를 반영하지 않았기 때문에, 이전 데이터를 반환할 수 있습니다.

### 6.3 **해결 방법**

- **지연 적용 알고리즘 (Lag Compensating Logic)**
    - 쓰기 후 즉시 읽기를 시도하는 경우, 잠시 지연을 두고 읽기를 재시도하는 방법입니다.
    - 지연된 시간만큼의 시간이 지나면, 대부분의 경우 읽기 DB가 최신 데이터를 반영하게 됩니다.
- **쓰기 DB로의 직접 읽기 (Read-after-Write)**
    - 중요한 데이터에 대해 쓰기 직후 즉시 읽어야 하는 경우, 해당 읽기 작업을 쓰기 DB에서 직접 수행하도록 합니다.
    - 이를 통해 최신 데이터를 즉시 읽어올 수 있습니다.
- **읽기 DB와 쓰기 DB 간의 복제 지연 최소화**
    - 복제 지연을 최소화하도록 데이터베이스 설정을 조정할 수 있습니다. 예를 들어, MySQL의 경우 복제 지연을 줄이기 위해 semi-synchronous replication을 사용하거나, 다른 복제 설정을 최적화할 수 있습니다.
    - 그러나 물리적인 네트워크 지연이나 시스템 부하 등으로 인해 지연을 완전히 제거할 수는 없습니다.
- **CQRS 패턴**
    - Command Query Responsibility Segregation (CQRS) 패턴을 적용하여, 쓰기 작업과 읽기 작업을 명확히 분리하고, 읽기 작업에 대해 일관성을 보장하는 별도의 메커니즘을 적용할 수 있습니다.
    - 예를 들어, 쓰기 DB의 변경이 읽기 DB에 완전히 반영된 후에야 읽기 작업을 허용하는 방식을 도입할 수 있습니다.
- **캐시 사용**
    - 캐시 시스템을 도입하여, 쓰기 작업 후 바로 캐시를 갱신하고, 그 이후의 읽기 작업은 캐시에서 제공하는 방식을 사용합니다. 캐시는 일관성을 보장하기 위해 일정 시간 동안(예: 1초) 쓰기 DB의 데이터를 캐시하는 방법을 사용할 수 있습니다.
    - 예시 :
    ```java
        @Cacheable(value = "products", key = "#id")
        public Product createProduct(Long id) {
            simulateSlowService();
            return new Product(id, "Product " + id, 100.0);
        }
        @CachePut(value = "products", key = "#product.id")
        public Product updateProduct(Product product) {
            // 실제 데이터베이스 업데이트 로직이 있다고 가정
            return product;
        }
    ```