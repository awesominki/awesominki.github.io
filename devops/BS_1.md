---
layout: page
title: 1. 대규모 시스템 개요
description: >
hide_description: true
sitemap: false
---

>📌 메시징 시스템을 개발하는 것을 예로 들어보겠습니다.
어떠한 기준으로 시스템을 설계해야 할까요?


## 1.1 동시 접속자와 초당 요청량(TPS)

### 1.1.1 사용자수

- 대규모 시스템을 설계할 때 가장 중요한 요소 중 하나는 사용자 수입니다.
    - 얼마나 많은 사용자가 시스템을 사용할 것인지 파악하는 것이 중요합니다. 기존 시스템에 새로운 기능을 추가하는 경우, 시스템 모니터링을 통해 하루에 몇 명의 사용자가 접속하는지 알 수 있습니다. 그러나 단순히 하루 접속량을 파악하는 것만으로는 충분하지 않습니다. 더 중요한 것은 동시 접속자의 요청 수입니다.

### 1.1.2 TPS (TPS, Transactions Per Second)

- TPS란?

  TPS (Transactions Per Second)는 초당 처리되는 트랜잭션의 수를 나타내는 지표입니다. 이는 시스템의 성능을 평가하는 중요한 지표 중 하나로, 특히 대규모 시스템에서 중요한 역할을 합니다. TPS는 시스템이 얼마나 많은 요청을 동시에 처리할 수 있는지를 나타내며, 시스템의 처리 능력을 가늠할 수 있게 해줍니다.

- 시스템이 초당 요청량(TPS, Transactions Per Second)을 견딜 수 있어야 합니다.
    - 이를 위해서는 일간 접속량이 아닌, 특정 시간대에 초당 접속자 요청량이 가장 많은 시간을 파악해야 합니다. 이 정보는 시스템의 용량 계획을 세우는 데 매우 중요합니다.
        - 예를 들어, 기존 시스템이 오전 9시 30분에 초당 200건의 요청을 처리했다고 가정해 보겠습니다. 이러한 데이터를 기반으로 시스템의 용량을 결정해야 합니다. 우리의 목표는 시스템이 예상치 못한 최대 부하를 견딜 수 있도록 하는 것입니다. 따라서 200건을 기준으로 1.5배인 300건을 처리할 수 있도록 시스템을 설계하는 것이 바람직합니다. 이는 시스템이 예기치 않은 트래픽 급증에도 견딜 수 있는 여유를 제공할 것입니다.
- 예상치 못한 이벤트로 인해 설계 예상 이상의 요청이 몰린다면 시스템이 중단될 수 있습니다.
    - 이러한 상황을 대비하기 위해서는 다양한 방법을 고려해야 합니다. 이러한 방법들을 통해 시스템의 안정성을 높일 수 있습니다.
        - 첫째, 애플리케이션의 수를 늘리는 방법이 있습니다.
        - 둘째, 오류 상황에서 사용자가 대기할 수 있도록 대기열을 설정하는 것도 하나의 방법입니다.
        - 셋째, 자동 스케일링을 통해 시스템의 자원을 동적으로 할당하여 부하를 분산시키는 것도 중요합니다.

## 1.2 요청 종류에 따른 개발

>📌 시스템이 읽기 전용인지, 쓰기 및 업데이트를 위한 것인지도 중요합니다. 이를 파악하고 처리 속도를 빠르게 하여 응답한다면 보다 많은 사용자를 수용할 수 있습니다.

- 데이터 제공 및 저장에서 가장 많은 시간을 소모하는 부분은 대부분 DB에서 데이터를 조회하거나 쓰는 것입니다.
- 요청 종류에 따라 이 부분의 허들을 최소화하는 것이 중요합니다.

### 1.2.1 읽기 요청 최적화

- 캐시 사용
    - 모든 사용자가 같은 데이터를 요청하는 경우, 이를 해소하기 위해 DB의 데이터를 레디스 같은 캐시에 올려두면 요청에 대한 응답 속도를 빠르게 할 수 있습니다.
    - 캐시를 사용하면 데이터를 빠르게 제공할 수 있으며, DB의 부하를 줄일 수 있습니다.
    - 개인화 데이터가 아니라면 캐시를 사용하여 데이터 로드에 시간 소요를 최소화 하는 방법이 중요합니다.
    - 데이터에서 필터된 데이터를 가져오는것보다 레디스에서 필터된 데이터를 가져오거나 애플리케이션 로직에서 필터링을 수행하는것이 더 큰 성능상의 이점을 가질 것입니다.
    - 엣지 단에서 캐싱을 처리하면 시스템의 요청 처리량이 줄어들어 적은 수의 애플리케이션으로도 요청을 처리할 수 있습니다. 엣지 캐싱은 사용자와 가까운 곳에서 데이터를 제공하므로 네트워크 지연을 최소화하고, 사용자 경험을 향상시킬 수 있습니다.
    - 캐싱 전략을 설계할 때는 캐시 갱신 정책도 중요합니다. 예를 들어, 공지사항이 자주 변경되지 않는 경우에는 캐시의 유효 기간을 길게 설정할 수 있습니다. 반면, 변경이 잦은 경우에는 짧은 유효 기간을 설정하거나, 변경 시점에 캐시를 무효화하여 최신 데이터를 제공할 수 있도록 해야 합니다. 이러한 캐싱 전략을 통해 시스템의 효율성을 극대화할 수 있습니다.
    - 데이터 소실의 위험을 줄이기 위해 데이터의 유효성을 지속적으로 검증하고, 데이터가 손실되지 않았는지 확인해야 합니다. 또한, 캐시 계층에서 데이터 소실 시 재요청을 통해 데이터베이스에서 데이터를 다시 가져올 수 있도록 해야 합니다.

- 데이터 베이스 사용 최적화
    - **데이터베이스 인덱싱** : 데이터베이스 인덱싱은 조회 성능을 크게 향상시킬 수 있는 방법입니다. 인덱스를 사용하면 데이터베이스는 데이터를 빠르게 검색할 수 있습니다. 올바르게 설계된 인덱스는 읽기 성능을 최적화하고 쿼리 응답 시간을 줄입니다. 주의할 점은 인덱스가 너무 많으면 쓰기 성능이 저하될 수 있다는 것입니다.
    - **데이터베이스 샤딩** : 데이터베이스 샤딩은 데이터베이스를 여러 샤드로 분할하여 각각의 샤드가 독립적으로 쿼리를 처리하도록 하는 방법입니다. 이를 통해 단일 데이터베이스에 대한 부하를 분산시킬 수 있으며, 읽기 요청에 대한 응답 속도를 향상시킬 수 있습니다. 예를 들어, 사용자 데이터를 여러 샤드에 분산 저장하여 읽기 성능을 최적화할 수 있습니다.
        - 예를 들어 테이블 파티셔닝을 생각해볼 수 있습니다. 이는 기본적인 형태의 샤딩으로, 데이터베이스 수준에서 데이터를 분할합니다.

            ```yaml
            CREATE TABLE orders (
              order_id SERIAL PRIMARY KEY,
              customer_id INT,
              order_date DATE,
              amount DECIMAL
            ) PARTITION BY RANGE (order_date);
            
            CREATE TABLE orders_2023_01 PARTITION OF orders FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');
            CREATE TABLE orders_2023_02 PARTITION OF orders FOR VALUES FROM ('2023-02-01') TO ('2023-03-01');
            
            ```

    - **읽기 전용 데이터베이스** : 읽기 전용 데이터베이스는 주로 읽기 요청을 처리하는 데이터베이스 인스턴스입니다. 데이터를 주기적으로 동기화하여 최신 상태를 유지하면서 읽기 요청을 처리합니다. 이 방법은 주 데이터베이스에 대한 읽기 부하를 줄이고 성능을 최적화할 수 있습니다.
    - **쿼리 최적화** : 쿼리 최적화는 SQL 쿼리를 효율적으로 작성하여 데이터베이스의 읽기 성능을 향상시키는 방법입니다. 예를 들어, 불필요한 조인을 줄이고, 필요한 컬럼만 선택하며, 적절한 조건을 사용하는 것이 중요합니다. 쿼리 실행 계획을 분석하여 병목 지점을 찾아내고, 이를 최적화할 수 있습니다.

### 1.2.2 쓰기 요청 최적화

- 쓰기에서 가장 많은 시간을 소요하는 부분은 DB에 데이터를 생성하는 부분입니다. 이를 해결하기 위한 다양한 방법이 있습니다.
- 비동기 처리
    - 쓰기 요청을 비동기 방식으로 처리하면 DB에 직접 접근하지 않고도 빠르게 응답을 반환할 수 있습니다
    - 예를 들어 메시지를 바로 DB에 쓰지 않고, 큐에 넣어 나중에 처리하는 방법이 있습니다
    - 이를 통해 애플리케이션은 요청을 빠르게 처리할 수 있습니다
    - 비동기 처리는 특히 높은 트래픽을 처리할 때 유용합니다
    - 사용자는 요청을 보낸 후 즉시 응답을 받기 때문에, 사용자 경험이 향상됩니다
    - 비동기 처리 시 데이터 소실이나 오류를 방지하기 위해 큐에 데이터를 넣을 때 적절한 검증을 수행하고, 큐에 쌓인 데이터를 지속적으로 모니터링하여 실패한 요청을 재시도할 수 있는 메커니즘을 마련해야 합니다
    - 또한, 데이터의 순서를 보장하고, 중복 처리를 방지하기 위한 고유 식별자(ID)를 사용해야 합니다

- 배치 처리
    - 실시간으로 처리할 필요가 없는 쓰기 요청은 배치 처리를 통해 한꺼번에 처리할 수 있습니다
    - 예를 들어 일정 시간마다 큐에 쌓인 메시지를 DB에 쓰는 방법이 있습니다.
    - 예를 들어, 매일 자정에 하루 동안 수집된 로그 데이터를 한 번에 DB에 저장하는 방식으로 사용할 수 있습니다.
    - 이를 통해 실시간 처리의 부담을 줄이고, 시스템 자원을 효율적으로 사용할 수 있습니다.
    - 배치 처리 시에도 데이터 소실을 방지하기 위해 배치 작업 중 오류가 발생한 경우 이를 기록하고, 재시도할 수 있는 메커니즘을 마련해야 합니다.
    - 또한, 배치 작업의 상태를 모니터링하고, 배치 작업이 완료되었는지 확인하는 프로세스를 마련해야 합니다.

- 분산 DB
    - 단일 DB로 모든 쓰기 요청을 처리하기 어렵다면, 분산 DB를 사용하여 부하를 분산시킬 수 있습니다
    - 예를 들어 여러 개의 DB 인스턴스를 사용하여 각 인스턴스가 특정 사용자 그룹의 데이터를 처리하도록 할 수 있습니다
    - 분산 DB는 데이터를 여러 개의 노드에 분산 저장하여 고가용성과 확장성을 제공합니다
    - 또한, 샤딩(Sharding) 기법을 통해 데이터베이스를 수평으로 분할하여 각 샤드가 독립적으로 쓰기 작업을 처리하도록 할 수 있습니다. 이를 통해 단일 노드의 부하를 줄이고, 시스템의 전체 성능을 향상시킬 수 있습니다.

    >📌 분산 DB 사용 시 데이터 일관성을 유지하기 위해 트랜잭션 관리와 데이터 동기화에 신경 써야 합니다. 예를 들어, 분산 트랜잭션이나 이벤트 소싱을 사용하여 데이터 일관성을 유지할 수 있습니다.
  


## 1.3 데이터 일관성 유지

>📌 대규모 시스템에서는 데이터 일관성을 유지하는 것이 중요합니다. 이를 위해 분산 트랜잭션, 이벤트 소싱, CQRS(Command Query Responsibility Segregation) 등의 기법을 사용할 수 있습니다.


### 1.3.1 분산 트랜잭션

- 분산 트랜잭션은 여러 개의 독립된 시스템이나 데이터베이스에서 동시에 일어나는 트랜잭션을 일관되게 관리하는 방법입니다.
- 단일 트랜잭션이 여러 시스템에 걸쳐 발생할 때, 모든 시스템이 해당 트랜잭션을 성공적으로 완료하거나, 모든 시스템이 트랜잭션을 실패로 처리하도록 보장합니다. 이를 통해 데이터의 일관성을 유지할 수 있습니다.
- 분산 트랜잭션이 필요한 이유는 마이크로서비스 아키텍처에서 여러 서비스가 독립적으로 운영되기 때문입니다
- 주요개념
    - **트랜잭션(Transaction)**:
        - 데이터베이스의 상태를 변환하는 작업의 단위로, ACID(원자성, 일관성, 고립성, 지속성) 속성을 보장합니다.
            - **원자성 (Atomicity)**: 트랜잭션은 전부 성공하거나 전부 실패하여, 부분적인 작업 수행이 없는 것을 보장합니다.
            - **일관성 (Consistency)**: 트랜잭션이 완료된 후에도 데이터베이스는 모든 무결성 제약 조건을 유지합니다.
            - **격리성 (Isolation)**: 동시에 실행되는 트랜잭션이 서로 간섭하지 않도록 보장합니다.
            - **지속성 (Durability)**: 트랜잭션이 성공적으로 완료된 후의 결과는 시스템 장애가 발생해도 영구적으로 유지됩니다.
    - **분산 트랜잭션(Distributed Transaction)**:
        - 여러 분산된 데이터 소스에 걸쳐 트랜잭션을 수행하는 작업입니다. 예를 들어, 여러 마이크로서비스나 데이터베이스에서 데이터를 동시에 업데이트하는 경우가 이에 해당합니다.
    - **2PC (Two-Phase Commit)**:
        - 분산 트랜잭션을 관리하는 프로토콜로, 준비(Prepare) 단계와 커밋(Commit) 단계로 나누어 트랜잭션을 처리합니다.
            - **준비 단계(Prepare Phase)**: 각 참여 노드는 트랜잭션 준비 상태를 확인하고, 준비 완료를 마스터 노드에 알립니다.
            - **커밋 단계(Commit Phase)**: 마스터 노드는 모든 참여 노드가 준비되었음을 확인하고, 트랜잭션을 커밋하도록 지시합니다. 만약 준비가 완료되지 않은 노드가 있다면 트랜잭션을 롤백합니다.
    - **사가 패턴(Saga Pattern)**:
        - 트랜잭션을 여러 단계로 나누어 처리하고, 각 단계가 독립적으로 커밋됩니다. 실패 시 보상 트랜잭션을 실행하여 상태를 롤백합니다.
            - **주문 생성 단계**: 사용자가 주문을 생성합니다.
            - **결제 처리 단계**: 결제 서비스가 주문 결제를 처리합니다.
            - **재고 감소 단계**: 재고 서비스가 주문된 상품의 재고를 감소시킵니다.
            - 각 단계가 성공적으로 완료되면 다음 단계로 넘어가고, 실패하면 이전 단계에서 수행된 작업을 취소합니다.
    - **이벤트 소싱(Event Sourcing)**:
        - 상태 변화를 이벤트로 기록하고, 해당 이벤트를 재생하여 현재 상태를 유지합니다. 이를 통해 분산 트랜잭션의 일관성을 유지할 수 있습니다.

- 분산 트랜잭션의 장점
    - **데이터 일관성 보장**:
        - 분산된 여러 데이터 소스에 걸쳐 일관된 데이터 상태를 유지할 수 있습니다. 모든 트랜잭션이 성공적으로 완료되거나 모두 실패하도록 보장합니다.
    - **확장성**:
        - 분산 트랜잭션을 통해 여러 시스템이 독립적으로 동작하면서도, 필요한 경우 협력하여 일관된 상태를 유지할 수 있습니다. 이를 통해 시스템의 확장성을 높일 수 있습니다.
    - **신뢰성**:
        - 트랜잭션의 ACID 속성을 분산 환경에서도 유지할 수 있어 시스템의 신뢰성을 높입니다. 데이터 무결성과 일관성을 유지할 수 있습니다.
    - **복구 가능성**:
        - 트랜잭션 실패 시 롤백 메커니즘을 통해 상태를 복구할 수 있어, 시스템 안정성을 높일 수 있습니다.

- 분산 트랜잭션의 단점
    - **복잡성 증가**:
        - 분산 트랜잭션을 구현하고 관리하는 것은 복잡합니다. 특히, 여러 시스템 간의 트랜잭션 동기화와 데이터 일관성을 유지하는 것은 어려운 작업입니다.
    - **성능 저하**:
        - 2PC와 같은 프로토콜을 사용할 경우, 트랜잭션의 준비와 커밋 단계에서 지연이 발생할 수 있습니다. 이는 시스템의 성능을 저하시킬 수 있습니다.
    - **네트워크 오버헤드**:
        - 여러 시스템 간의 통신이 필요하므로 네트워크 오버헤드가 증가할 수 있습니다. 이는 트랜잭션 처리 속도를 저하시킬 수 있습니다.
    - **복구의 어려움**:
        - 분산 트랜잭션 실패 시, 모든 시스템에서 일관된 상태로 롤백하는 것이 어려울 수 있습니다. 특히, 부분적으로 실패한 트랜잭션을 처리하는 데 어려움이 있을 수 있습니다.

- 분산 트랜잭션의 예시
    - **주문 생성과 결제 처리**:
        - 한 사용자가 온라인 쇼핑몰에서 주문을 생성하고, 결제를 진행합니다. 이 과정에서 주문 서비스와 결제 서비스가 각각 독립된 데이터베이스를 사용한다고 가정합니다.
        - 분산 트랜잭션을 통해 두 서비스가 일관되게 주문과 결제를 처리해야 합니다. 트랜잭션이 성공적으로 완료되면 두 데이터베이스에 주문 및 결제 정보가 일관되게 저장됩니다.
    - **2PC를 사용한 트랜잭션 처리**:
        - **준비 단계**: 주문 서비스와 결제 서비스가 트랜잭션을 준비합니다. 두 서비스가 모두 준비 완료 상태를 마스터 노드에 알립니다.
        - **커밋 단계**: 마스터 노드는 두 서비스가 모두 준비되었음을 확인하고, 트랜잭션을 커밋하도록 지시합니다. 만약 하나의 서비스라도 준비되지 않았으면, 트랜잭션을 롤백합니다.

### 1.3.2 이벤트 소싱

- 이벤트 소싱은 데이터 상태 변화를 이벤트로 기록하고, 해당 이벤트들을 순차적으로 재생하여 현재 상태를 파악하는 방법입니다.
- 전통적인 데이터 저장 방식과 달리, 이벤트 소싱에서는 데이터 변경 자체가 아닌 변경 이벤트를 저장합니다
- 이러한 방식은 특히 복잡한 비즈니스 로직을 다루는 시스템에서 데이터 일관성과 추적 가능성을 높이는 데 유용합니다
- 하지만 복잡성이 증가할 수 있으므로, 시스템의 요구사항에 따라 신중하게 적용해야 합니다

- 주요개념
    - **이벤트(Event)**:
        - 데이터의 상태 변화를 나타내는 기록입니다. 예를 들어, "주문 생성", "결제 완료", "주문 취소" 등이 이벤트가 될 수 있습니다.
    - **이벤트 스토어(Event Store)**:
        - 이벤트를 저장하는 저장소입니다. 전통적인 데이터베이스 대신 이벤트를 순서대로 저장하는 스토리지입니다. 이는 이벤트의 불변성과 순차성을 보장합니다.
    - **애그리게이트(Aggregate)**:
        - 관련된 이벤트를 모아 현재 상태를 재현할 수 있는 엔터티입니다. 애그리게이트는 도메인 모델의 일부분으로, 이벤트를 적용하여 상태를 변화시킵니다.
    - **커맨드(Command)**:
        - 애그리게이트에 특정 동작을 지시하는 명령입니다. 커맨드는 이벤트를 생성하는 트리거 역할을 합니다.
    - **프로젝션(Projection)**:
        - 이벤트를 읽기 모델로 변환하여 조회 성능을 최적화하는 방식입니다. 이벤트를 기반으로 읽기 전용 데이터베이스를 업데이트합니다.
- 이벤트 소싱의 장점
    - **데이터 변경 이력 추적**:
        - 모든 상태 변화를 이벤트로 기록하므로, 데이터 변경 이력을 완벽하게 추적할 수 있습니다. 이는 감사와 디버깅에 유용합니다.
    - **복구 및 재생**:
        - 이벤트를 재생하여 시스템의 현재 상태를 복구할 수 있습니다. 이는 데이터 손실이나 시스템 장애 시 유용합니다.
    - **CQRS와의 자연스러운 통합**:
        - 이벤트 소싱은 CQRS(Command Query Responsibility Segregation)와 잘 어울립니다. 명령과 조회를 분리하여 성능과 확장성을 최적화할 수 있습니다.
- 이벤트 소싱의 단점
    - **복잡성 증가**:
        - 시스템 설계와 구현의 복잡성이 증가합니다. 이벤트 모델링과 이벤트 스토어 관리가 필요합니다.
    - **읽기 성능**:
        - 이벤트를 재생하여 현재 상태를 계산해야 하므로, 읽기 성능이 저하될 수 있습니다. 이를 해결하기 위해 프로젝션과 CQRS를 활용할 수 있습니다.



### 1.3.3 CQRS

- CQRS는 **명령(Query)과 조회(Query)의 책임을 분리**하는 소프트웨어 디자인 패턴입니다
- 이 패턴은 읽기 작업과 쓰기 작업을 서로 다른 모델로 분리하여, 각 작업에 최적화된 구조를 사용할 수 있도록 합니다
- CQRS는 시스템의 성능, 확장성, 유지보수성을 향상시키는 데 도움이 됩니다.

- 주요 개념
    - **명령(Command)**:
        - 데이터를 변경하는 작업입니다. 예를 들어, 주문 생성, 결제 처리, 계정 업데이트 등이 명령에 해당합니다. 명령은 데이터베이스에 대한 쓰기 작업을 수행합니다.
        - **명령 모델**은 데이터의 상태 변경을 담당합니다. 이는 복잡한 비즈니스 로직을 포함할 수 있으며, 데이터 무결성을 보장하기 위해 트랜잭션을 사용합니다.
    - **조회(Query)**:
        - 데이터를 조회하는 작업입니다. 예를 들어, 주문 내역 조회, 계정 정보 조회 등이 조회에 해당합니다. 조회는 데이터베이스에 대한 읽기 작업을 수행합니다.
        - **조회 모델**은 읽기 전용 데이터베이스 또는 캐시를 사용하여 빠른 응답을 제공합니다. 이는 단순한 데이터 조회를 위한 최적화된 구조를 가질 수 있습니다.
- CQRS의 장점
    - **성능 향상**:
        - 읽기와 쓰기를 분리하여 각 작업에 최적화된 데이터 저장소와 인프라를 사용할 수 있습니다. 예를 들어, 조회 성능을 높이기 위해 읽기 전용 데이터베이스를 사용하거나, 캐시를 활용할 수 있습니다.
    - **확장성**:
        - 읽기와 쓰기를 독립적으로 확장할 수 있습니다. 예를 들어, 읽기 요청이 많은 경우 조회 모델을 수평으로 확장하여 부하를 분산시킬 수 있습니다.
    - **유지보수성**:
        - 비즈니스 로직이 명령 모델에 집중되므로, 복잡한 상태 변경 로직을 관리하기 쉽습니다. 또한, 읽기 모델은 단순화되어 유지보수하기 용이합니다.
    - **데이터 일관성**:
        - CQRS는 이벤트 소싱과 잘 어울립니다. 이벤트 소싱을 통해 데이터 상태 변경을 이벤트로 기록하고, 이벤트를 재생하여 현재 상태를 유지할 수 있습니다. 이를 통해 데이터 일관성을 보장할 수 있습니다.

- CQRS의 단점
    - **복잡성 증가**:
        - 시스템 설계와 구현의 복잡성이 증가합니다. 명령 모델과 조회 모델을 각각 설계하고 관리해야 합니다.
    - **데이터 동기화**:
        - 명령 모델과 조회 모델 간의 데이터 동기화가 필요합니다. 이는 추가적인 구현과 관리가 필요합니다.

## 1.4 모니터링과 로깅

- 대규모 시스템에서 모니터링과 로깅은 시스템의 안정성과 성능을 유지하는 데 필수적인 역할을 합니다.
- 이를 통해 시스템의 상태를 실시간으로 파악하고, 문제 발생 시 신속하게 대응할 수 있습니다.
- 모니터링과 로깅 모두 다음의 항목을 주요 사항으로 봅니다.
    - **시스템 안정성 유지**
    - **성능 최적화**
    - **문제 예방 및 대응**

### 1.4.1 모니터링

- 애플리케이션, DB, 캐시 등 각 컴포넌트의 성능을 모니터링합니다
- 이를 위해 Prometheus, Grafana 같은 도구를 사용할 수 있습니다.
- 시스템의 주요 지표(TPS, 응답 시간, 에러율 등)를 모니터링하고, 이상 징후를 감지하면 알림을 받을 수 있습니다
- 모니터링을 통해 시스템의 상태를 실시간으로 파악하고, 문제 발생 시 빠르게 대응할 수 있습니다. 또한, 모니터링 데이터를 기반으로 시스템의 성능을 분석하고, 최적화할 수 있습니다.

- 주요사항
    - **실시간 상태 파악:**
        - 모니터링 도구는 시스템의 주요 지표(TPS, 응답 시간, 에러율 등)를 실시간으로 확인할 수 있게 합니다. 이를 통해 시스템의 현재 상태를 파악하고, 이상 징후를 빠르게 감지할 수 있습니다
    - **자동 알림:**
        - 특정 임계치를 초과하는 경우 자동으로 알림을 받을 수 있어, 잠재적인 문제를 조기에 발견하고 대응할 수 있습니다.
    - **성능 분석**:
        - 모니터링 데이터를 기반으로 시스템의 성능을 분석할 수 있습니다. 예를 들어, 특정 시간대에 트래픽이 급증하는 경우 해당 시간대에 자원을 추가로 할당하여 성능을 최적화할 수 있습니다.
    - **병목 지점 파악:**
        - 모니터링을 통해 시스템의 병목 지점을 파악하고, 이를 최적화하여 전체 성능을 향상시킬 수 있습니다.
    - **사전 예방**:
        - 실시간 모니터링을 통해 문제가 발생하기 전에 예방 조치를 취할 수 있습니다. 예를 들어, 디스크 사용량이 급증하는 경우 디스크 용량을 미리 확장할 수 있습니다.
    - **신속한 대응**:
        - 문제가 발생했을 때 빠르게 감지하고 대응할 수 있어, 시스템 다운타임을 최소화할 수 있습니다.

### 1.4.2 로깅

- 애플리케이션의 주요 이벤트를 로깅하여 문제 발생 시 원인을 추적할 수 있습니다
- 로그는 Elasticsearch, Logstash, Kibana(ELK 스택) 등을 사용하여 수집, 저장, 분석할 수 있습니다
- 이를 통해 시스템의 상태를 파악하고, 문제를 해결할 수 있습니다.
- 로깅은 시스템의 모든 중요한 이벤트를 기록하므로, 문제 발생 시 정확한 원인을 파악하는 데 큰 도움이 됩니다

- 주요사항
    - **이벤트 추적:**
        - 로깅을 통해 시스템에서 발생하는 모든 중요한 이벤트를 기록합니다. 이는 문제가 발생했을 때 원인을 추적하고 분석하는 데 도움이 됩니다
    - **디버깅 및 오류 해결:**
        - 로그를 분석하여 오류의 원인을 파악하고, 이를 기반으로 문제를 해결할 수 있습니다. 이는 특히 복잡한 대규모 시스템에서 문제 해결 시간을 단축시킵니다.
    - **패턴 분석:**
        - 로그 데이터를 분석하여 사용자의 행동 패턴이나 시스템의 성능 패턴을 이해할 수 있습니다. 이를 통해 시스템을 더 효율적으로 운영할 수 있습니다.
    - **장기적 최적화**:
        - 로그 데이터를 장기적으로 분석하여 시스템의 성능 저하 원인을 찾아내고, 지속적인 최적화를 진행할 수 있습니다.
    - **원인 분석**:
        - 문제가 발생한 후 로그를 분석하여 정확한 원인을 파악할 수 있습니다. 이는 같은 문제가 다시 발생하지 않도록 예방하는 데 도움이 됩니다.
    - **법적 및 규제 요구 사항 준수**:
        - 많은 산업에서는 로그 데이터를 보관하고 분석하는 것이 법적 및 규제 요구 사항을 준수하는 데 필수적입니다. 이는 감사 및 규제 대응에 중요한 역할을 합니다.

## 1.5 테스트와 배포

- 대규모 시스템에서는 테스트와 배포도 중요한 요소입니다.
- 시스템이 정상적으로 동작하는지 확인하고, 문제 발생 시 빠르게 대응할 수 있어야 합니다.

### 1.5.1 테스트

- **단위 테스트(Unit Test):**
    - 시스템의 개별 구성 요소를 테스트하여 각 부분이 예상대로 동작하는지 확인합니다.
    - JUnit, TestNG와 같은 도구를 사용하여 자동화된 단위 테스트를 작성하고 실행합니다.
    - 단위 테스트는 개발 초기 단계에서 발생할 수 있는 결함을 조기에 발견하고 수정하는 데 유용합니다.
- **통합 테스트(Integration Test)**
    - 여러 구성 요소가 함께 동작하는지를 테스트합니다. 이는 개별 구성 요소들이 올바르게 상호작용하는지를 검증합니다.
    - Spring Boot에서는 @SpringBootTest 어노테이션을 사용하여 통합 테스트를 작성할 수 있습니다.
    - 통합 테스트는 시스템의 다양한 부분들이 함께 올바르게 동작하는지를 확인하여, 인터페이스 간의 문제를 발견하는 데 유용합니다.
- **부하 테스트(Load Test)**:
    - 시스템이 높은 트래픽 상황에서도 안정적으로 동작하는지를 테스트합니다.
    - Apache JMeter와 같은 도구를 사용하여 다양한 부하 시나리오를 설정하고 테스트를 수행합니다.
    - 부하 테스트를 통해 시스템의 성능 한계를 파악하고, 병목 지점을 찾아 최적화할 수 있습니다.
- **회귀 테스트(Regression Test)**:
    - 새로운 코드 변경이 기존 기능에 영향을 미치지 않는지 확인합니다.
    - 기존 테스트 케이스를 자동화하여 주기적으로 실행함으로써, 코드 변경으로 인한 결함을 방지할 수 있습니다.
    - 회귀 테스트는 지속적인 코드 변경에도 시스템의 안정성을 유지하는 데 중요합니다.
- **사용자 수용 테스트(UAT, User Acceptance Test)**:
    - 실제 사용자 환경에서 시스템을 테스트하여, 사용자가 요구하는 기능이 모두 제대로 동작하는지 확인합니다.
    - 사용자 피드백을 반영하여 시스템을 최종 조정하고, 배포 준비를 완료합니다.
    - 사용자 수용 테스트는 시스템이 실제 운영 환경에서 기대대로 동작하는지 확인하는 중요한 단계입니다.

### 1.5.2 배포

- **지속적인 통합(CI, Continuous Integration)**:
    - 개발자가 변경한 코드를 자주, 자동으로 빌드하고 테스트하여, 코드 변경 시점에서 발생할 수 있는 문제를 조기에 발견하고 해결합니다.
    - Jenkins, GitLab CI, Travis CI와 같은 도구를 사용하여 CI 파이프라인을 설정합니다.
    - CI는 코드 통합을 빠르고 효율적으로 수행하여 개발 주기를 단축시키고, 코드 품질을 높입니다.
- **지속적인 배포(CD, Continuous Deployment)**:
    - CI 파이프라인을 통해 검증된 코드를 자동으로 프로덕션 환경에 배포합니다.
    - Argo CD와 같은 도구를 사용하여 CD 파이프라인을 설정합니다.
    - CD는 코드 변경 사항을 빠르고 안전하게 프로덕션 환경에 적용하여, 새로운 기능을 신속하게 제공할 수 있습니다.
- **Canary 배포**:
    - 새로운 버전을 전체 시스템에 배포하기 전에, 일부 사용자에게만 배포하여 문제가 없는지 확인합니다.
    - 문제가 발생할 경우 빠르게 이전 버전으로 롤백할 수 있습니다.
    - Canary 배포는 리스크를 최소화하면서 새로운 기능을 단계적으로 도입할 수 있는 방법입니다.
- **블루-그린 배포(Blue-Green Deployment)**:
    - 두 개의 환경(블루와 그린)을 사용하여 하나는 현재 운영 중인 환경이고, 다른 하나는 새로운 버전을 배포하는 환경으로 사용합니다.
    - 새로운 버전을 그린 환경에 배포한 후, 모든 트래픽을 그린 환경으로 전환합니다. 문제가 발생하면 블루 환경으로 빠르게 롤백할 수 있습니다.
    - 블루-그린 배포는 무중단 배포를 가능하게 하며, 배포 실패 시 신속한 복구를 제공합니다.
- **롤링 배포(Rolling Deployment)**:
    - 새로운 버전을 점진적으로 배포하여, 각 서버를 순차적으로 업데이트합니다.
    - 시스템 가동 시간을 유지하면서 점진적으로 새로운 버전을 도입할 수 있습니다.
    - 롤링 배포는 대규모 시스템에서 무중단 배포를 구현하는 데 유용합니다.