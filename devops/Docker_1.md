---
layout: page
title: 1. Docker
description: >
hide_description: true
sitemap: false
---

## 1.1 Docker개요

### 1.1.1 Docker란?

- **Docker**
    - Docker는 애플리케이션을 쉽게 만들고, 테스트하고, 배포할 수 있게 도와주는 소프트웨어 플랫폼입니다.
    - 애플리케이션을 컨테이너라는 가볍고 이식성 있는 패키지로 실행할 수 있습니다.
    - Docker 이미지는 애플리케이션을 실행하는 데 필요한 모든 것(코드, 런타임, 시스템 도구, 시스템 라이브러리 등)을 포함합니다.

- 주요 특징
    - **컨테이너화**: 애플리케이션과 필요한 모든 것을 하나의 패키지로 묶어 어디서든 실행할 수 있습니다.
    - **경량**: Docker는 운영 체제의 커널을 공유하므로, 가상 머신보다 훨씬 가볍고 빠르게 실행됩니다.
    - **이식성**: Docker 컨테이너는 어디서든 동일하게 실행됩니다. 예를 들어, 개발자의 컴퓨터에서 테스트 서버, 운영 서버까지 동일하게 동작합니다.
    - **확장성**: Docker를 사용하면 여러 개의 컨테이너를 효율적으로 관리하고 쉽게 확장할 수 있습니다.

- 주요 키워드

    >💡 키워드 정리

    - **이미지:** 애플리케이션과 모든 실행에 필요한 파일을 포함한 읽기 전용 템플릿
    - **컨테이너:** 이미지를 실행하여 동작하는 애플리케이션 인스턴스
    - **Dockerfile:** 이미지를 생성하기 위한 명령어가 담긴 스크립트 파일
    - **Docker Hub:** 이미지를 저장하고 공유하는 중앙 저장소
    - **볼륨:** 컨테이너 데이터를 지속적으로 저장하는 메커니즘
    - **네트워크:** 컨테이너 간의 통신을 관리하는 방식


    - **이미지 (Image)**
        - Docker 이미지는 애플리케이션과 그 실행에 필요한 모든 것을 포함하는 읽기 전용 템플릿입니다. 이미지에는 코드, 런타임, 라이브러리, 환경 변수, 구성 파일 등이 포함됩니다.
        - 이미지는 컨테이너를 생성하기 위한 청사진 역할을 합니다.
    - **컨테이너 (Container)**
        - 컨테이너는 Docker 이미지를 실행한 상태입니다. 이미지가 정적인 템플릿이라면, 컨테이너는 실제로 애플리케이션이 실행되는 동적인 환경입니다.
        - 컨테이너는 격리된 공간에서 애플리케이션을 실행하며, 필요한 모든 의존성을 포함합니다.
        - 하나의 시스템에서 여러 개의 컨테이너를 독립적으로 실행할 수 있습니다.
    - **Dockerfile**
        - Dockerfile은 Docker 이미지를 생성하기 위한 스크립트입니다. 이 파일에는 이미지를 빌드하는 데 필요한 명령어들이 포함되어 있습니다.
        - Dockerfile을 사용하면 이미지 생성 과정을 자동화하고 일관되게 만들 수 있습니다.
    - **Docker Hub**
        - Docker Hub는 Docker 이미지를 공유하고 저장하는 중앙 저장소입니다. 사용자는 Docker Hub에서 다양한 공개 이미지를 다운로드하거나 자신만의 이미지를 업로드할 수 있습니다.
    - **볼륨 (Volume)**
        - 볼륨은 컨테이너의 데이터를 지속적으로 저장할 수 있는 메커니즘입니다. 컨테이너가 삭제되더라도 볼륨에 저장된 데이터는 유지됩니다.
        - 볼륨을 사용하면 데이터를 컨테이너와 독립적으로 관리할 수 있습니다.
    - **네트워크 (Network)**
        - Docker 네트워크는 컨테이너 간의 통신을 관리하는 방식입니다. Docker는 여러 가지 네트워크 드라이버를 제공하여 다양한 네트워크 설정을 지원합니다.
        - 기본적으로 모든 컨테이너는 브리지 네트워크를 통해 통신할 수 있습니다.
        - 네트워크 종류
            - **Bridge Network (브리지 네트워크)**
                - 기본적으로 Docker가 컨테이너를 실행할 때 사용하는 네트워크입니다.
                - 동일한 브리지 네트워크에 연결된 컨테이너들은 서로 통신할 수 있습니다.
                - 외부 네트워크와는 NAT (*내부 네트워크의 여러 장치가 하나의 공용 IP 주소를 통해 외부 네트워크와 통신할 수 있도록 IP 주소를 변환하는 기술*) 를 통해 통신합니다.
                - 일반적으로 단일 호스트에서 여러 컨테이너를 연결할 때 사용됩니다.
                - 명시하지 않으면 모두 브리지 네트워크에서 실행됩니다.

                ```bash
                docker network create my-bridge-network
                docker run -d --name container1 --network my-bridge-network nginx
                docker run -d --name container2 --network my-bridge-network nginx
                ```

            - **Host Network (호스트 네트워크)**
                - 컨테이너가 호스트의 네트워크 스택을 직접 사용합니다.
                - 네트워크 격리가 없기 때문에 성능상 이점이 있지만, 보안 및 네트워크 충돌 위험이 있습니다.
                - 일반적으로 성능이 중요한 애플리케이션에 사용됩니다.

                ```bash
                docker run -d --network host nginx
                ```

            - **Overlay Network (오버레이 네트워크)**
                - 여러 Docker 호스트에 걸쳐 있는 컨테이너를 연결할 때 사용됩니다.
                - Swarm 모드(*Docker 컨테이너의 오케스트레이션과 클러스터링을 지원하여 여러 호스트에서 컨테이너를 관리하고 배포할 수 있는 기능*)나 Kubernetes 같은 오케스트레이션 도구와 함께 사용됩니다.
                - 데이터 센터 또는 클라우드 환경에서 분산 시스템을 구축할 때 유용합니다.


### **1.1.2 Docker와 가상 머신의 비교**

- **Docker의 장점과 단점**
    - **장점**
        - **빠른 시작 시간과 낮은 오버헤드:** Docker 컨테이너는 애플리케이션만 실행하고, 운영 체제의 핵심 부분은 공유하므로, 가상 머신보다 훨씬 빠르게 시작할 수 있습니다.
        - **높은 이식성과 확장성:** Docker 컨테이너는 한 번 만들면 어디서든지 동일하게 실행됩니다. 예를 들어, 개발 환경, 테스트 환경, 실제 운영 환경 모두에서 같은 방식으로 동작합니다. 여러 컨테이너를 쉽게 추가하고 관리할 수 있어, 필요에 따라 애플리케이션을 확장하기 쉽습니다.
    - 단점
        - **보안 격리가 가상 머신보다 약함:** Docker 컨테이너는 동일한 운영 체제 커널을 공유하기 때문에, 가상 머신보다 보안 격리 수준이 낮습니다. 하나의 컨테이너에서 보안 문제가 발생하면, 같은 커널을 공유하는 다른 컨테이너에도 영향을 줄 가능성이 있습니다.
        - **운영 체제 종속성 존재:** Docker는 리눅스 커널을 사용하여 작동하므로, 리눅스 운영 체제에서 가장 잘 동작합니다. 윈도우나 맥 같은 다른 운영 체제에서는 호환성 문제가 있을 수 있고, 리눅스 커널을 에뮬레이션하는 방식으로 작동해야 하기 때문에 성능이 저하될 수 있습니다.

- **가상 머신(VM)의 장점과 단점**
    - 정의
        - 가상 머신(VM)은 하이퍼바이저를 통해 물리적 하드웨어 위에 가상화된 운영 체제를 실행하는 기술입니다. 하이퍼바이저는 여러 운영 체제를 동시에 실행할 수 있도록 물리적 하드웨어를 가상화하는 소프트웨어입니다.
    - 장점
        - **격리된 환경 제공:** 각 가상 머신은 완전히 독립된 운영 체제를 실행하므로, 하나의 가상 머신에서 문제가 발생해도 다른 가상 머신이나 호스트 시스템에 영향을 주지 않습니다.
        - **다양한 운영 체제 실행 가능:** 가상 머신을 사용하면 한 물리적 서버에서 여러 종류의 운영 체제를 동시에 실행할 수 있습니다. 예를 들어, 같은 컴퓨터에서 윈도우, 리눅스, 맥OS를 동시에 실행할 수 있습니다. 이를 통해 개발자나 테스트 팀은 다양한 환경을 쉽게 구축하고 사용할 수 있습니다.
    - 단점
        - **오버헤드가 크고, 느린 부팅 시간:** 가상 머신은 전체 운영 체제를 실행해야 하기 때문에, 많은 메모리(RAM)와 CPU 자원을 소비합니다. 가상 머신을 부팅할 때 운영 체제를 처음부터 시작해야 해서 시간이 오래 걸립니다. 이는 실제 하드웨어에서 컴퓨터를 켜는 것과 비슷합니다.
        - **높은 리소스 소비:** 가상 머신은 각기 독립된 운영 체제를 포함하므로, 여러 가상 머신을 실행하면 컴퓨터 자원을 많이 소모하게 됩니다. 예를 들어, 두 개의 가상 머신을 실행하면, 두 운영 체제를 모두 실행해야 하므로 메모리와 CPU 사용량이 크게 증가합니다. 이는 컴퓨터의 성능을 저하시킬 수 있습니다.

### **1.1.3 Docker는 언제 사용할까?**

- **일관된 개발 환경이 필요할 때**
    - 개발, 테스트, 운영 환경이 다를 때 발생하는 문제를 피하고자 할 때 Docker를 사용하면 좋습니다. Docker를 사용하면 모든 환경에서 동일한 컨테이너를 실행할 수 있어, 환경 차이로 인한 문제를 줄일 수 있습니다
- **애플리케이션을 빠르게 배포하고 싶을 때**
    - Docker를 사용하면 애플리케이션을 빠르고 쉽게 배포할 수 있습니다. Docker 이미지를 빌드하고 이를 컨테이너로 실행하면, 필요한 모든 구성 요소가 포함되어 있어 별도의 설치 과정 없이 바로 실행할 수 있습니다.
- **마이크로서비스 아키텍처를 도입할 때**
    - Docker는 마이크로서비스 아키텍처와 잘 맞습니다. 각 서비스가 독립적으로 배포되고 실행될 수 있어, 여러 개의 컨테이너를 통해 다양한 서비스를 쉽게 관리할 수 있습니다
- **CI/CD 파이프라인을 구축할 때**
    - Docker는 CI/CD 파이프라인에 적합합니다. 코드를 변경할 때마다 자동으로 빌드, 테스트, 배포할 수 있도록 설정할 수 있어, 개발 주기를 단축하고 배포의 신뢰성을 높일 수 있습니다.
- **리소스 효율성을 높이고 싶을 때**
    - Docker 컨테이너는 가상 머신보다 적은 리소스를 사용합니다. 운영 체제의 커널을 공유하므로, 더 많은 애플리케이션을 동일한 하드웨어에서 실행할 수 있습니다.
- **애플리케이션 격리가 필요할 때:**
    - 여러 애플리케이션을 독립적으로 실행하고자 할 때 Docker를 사용하면 각 컨테이너가 서로 격리되어 실행됩니다. 이를 통해 애플리케이션 간의 충돌을 방지하고 보안을 강화할 수 있습니다.
- **쉽게 스케일링하고 싶을 때:**
    - Docker를 사용하면 컨테이너 기반의 애플리케이션을 쉽게 확장할 수 있습니다. 필요한 만큼 컨테이너를 추가하여 수평 확장이 가능하며, 오케스트레이션 도구와 결합하여 자동 확장도 가능합니다.
- **쿠버네티스(Kubernetes)와 함께 사용하고자 할 때**
    - Docker는 쿠버네티스와 함께 사용하기에 매우 적합합니다. 쿠버네티스는 컨테이너 오케스트레이션 도구로, 다수의 Docker 컨테이너를 관리하고 자동 배포, 확장, 운영을 지원합니다. Docker 컨테이너를 쿠버네티스 클러스터에 배포하면, 애플리케이션의 가용성과 확장성을 높일 수 있습니다.


### **1.1.4 Docker 명령어**

- **이미지 관련 명령어**
    - 이미지 빌드 (Build)

        ```bash
        docker build -t myapp:latest .
        ```

        - 현재 디렉토리의 Dockerfile을 기반으로 myapp이라는 이름의 이미지를 생성합니다. -t 옵션을 사용하여 이미지의 이름과 태그를 입력 할 수 있습니다.

    - 이미지 가져오기

        ```bash
        docker pull postgres
        ```

        - 도커 허브에서 해당 이미지를 가져옴

    - 이미지 목록 보기 (List Images)

        ```bash
        docker images
        ```

        - 현재 로컬에 저장된 Docker 이미지를 목록으로 표시합니다.

    - **이미지 삭제**

        ```bash
        docker rmi myapp:latest
        ```

        - myapp:latest 이미지를 로컬 저장소에서 삭제합니다

- **Docker 컨테이너 관련 명령어**

>📌 컨테이너 아이디는 모두 작성할 필요없이 식별 가능한 자릿수까지만 입력하세요


    - **컨테이너 실행 (Run)**

        ```bash
        docker run -d -p 8080:80 myapp:latest
        ```

        - myapp:latest 이미지를 사용하여 컨테이너를 실행합니다. -d 옵션은 백그라운드에서 실행되도록 하고, -p 옵션은 호스트의 8080 포트를 컨테이너의 80 포트에 매핑합니다.
        - -d (detached mode): 컨테이너를 백그라운드에서 실행합니다. 이 옵션을 사용하면 터미널을 컨테이너에 붙잡히지 않고, 컨테이너가 백그라운드에서 계속 실행됩니다.

    - 컨테이너 내부 접속

        ```bash
        docker exec -it 컨테이너_아이디 /bin/bash
        ```

        - -i (interactive): 컨테이너의 표준 입력(STDIN)을 열어둡니다. 이 옵션을 사용하면 컨테이너 내부에서 사용자 입력을 받을 수 있습니다.
        - -t (tty): 가상 터미널을 할당합니다. 이 옵션을 사용하면 컨테이너 내부에서 터미널을 사용할 수 있습니다

    - **실행 중인 컨테이너 목록 보기 (List Running Containers)**

        ```bash
        docker ps
        ```

        - 현재 실행 중인 컨테이너의 목록을 표시합니다.

    - **모든 컨테이너 목록 보기 (List All Containers)**

        ```bash
        docker ps -a
        ```

        - 중지된 컨테이너를 포함한 모든 컨테이너의 목록을 표시합니다.

        ```bash
        docker ps -al
        ```

        - 마지막으로 실행된 컨테이너를 가장 먼저 나열.
    - **컨테이너 중지 (Stop)**

        ```bash
        docker stop container_id
        ```

        - 지정된 container_id를 가진 컨테이너를 중지합니다.

    - **컨테이너 시작 (Start)**

        ```bash
        docker start container_id
        ```

        - 중지된 컨테이너를 다시 시작합니다.

    - 컨테이너 삭제 (Remove Container)

        ```bash
        docker rm 컨테이너_아이디
        ```

        - 지정된 container_id를 가진 컨테이너를 삭제합니다.

- **Docker 네트워크 및 볼륨 관련 명령어**
    - **네트워크 생성 (Create Network)**

        ```bash
        docker network create mynetwork
        ```

        - mynetwork이라는 이름의 네트워크를 생성합니다.

    - **네트워크 목록 보기 (List Networks)**

        ```bash
        docker network ls
        ```

        - 현재 설정된 Docker 네트워크의 목록을 표시합니다.

    - **네트워크 삭제 (Remove Network)**

        ```bash
        docker nework rm mynetwork
        ```

        - mynetwork이라는 이름의 네트워크를 삭제합니다.

    - **볼륨 생성 (Create Volume)**

        ```bash
        docker volume create myvolume
        ```

        - myvolume이라는 이름의 볼륨을 생성합니다.

    - **볼륨 목록 보기 (List Volumes)**

        ```bash
        docker volume ls
        ```

        - 현재 설정된 Docker 볼륨의 목록을 표시합니다.

    - **볼륨 삭제 (Remove Volume)**

        ```bash
        docker volume rm myvolume
        ```

        - myvolume이라는 이름의 볼륨을 삭제합니다.


### **1.2 간단한 실습**


>📌 도커를 통해 PostgreSQL 컨테이너 2개를 실행해보겠습니다.


### 1.2.1 이미지 받기

```docker
docker pull postgres
```

### 1.2.2 컨테이너 실행하기

- :z 옵션은 SELinux(Secure Enhanced Linux) 환경에서 사용되는 파일 시스템 옵션입니다.
- 이 옵션은 Docker 컨테이너가 호스트 파일 시스템의 특정 디렉토리에 접근할 수 있도록 SELinux 컨텍스트를 설정합니다. SELinux는 Linux 시스템의 보안을 강화하기 위해 파일 및 프로세스에 대한 권한을 세밀하게 제어합니다.
- :z 옵션은 해당 볼륨이 여러 컨테이너에서 공유될 수 있음을 나타내며, 이를 통해 컨테이너가 해당 디렉토리에 읽기 및 쓰기 권한을 갖도록 합니다.

```docker
docker run -d --name postgres-sample \
  -p 5433:5432 \
	-e POSTGRES_USER=admin1 \
	-e POSTGRES_PASSWORD=admin2 \
	-e PGDATA=/var/lib/postgresql/data/pgdata \
	-v ${로컬_바인딩_폴더}:/var/lib/postgresql/data:z \
	postgres
```

- 만약 맥에서 실행시  Permission denied 관련 에러가 난다면 다음의 내용을 참고하세요
    - Rancher desktop 을 사용할 경우
        - Rancher desktop  윈도우에서 설정을 들어갑니다.
        - Virtual Machine > Volumes 로 들어가 Mount Type을 9p 로 변경합니다.
        - Security Model을 Mapped-xattr 로 변경합니다.
    - Docker desktop의 경우
        - Docker desktop 윈도우에서 설정에 들어갑니다.
        - General 탭에서 virtoFS을 oxsfs(Legacy)로 수정합니다.