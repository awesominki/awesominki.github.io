---
layout: page
title: Part 5-1 Array vs LinkedList
description: >
hide_description: true
sitemap: false
---

### Array

- 배열이며, 논리적 저장순서와 물리적 저장순서가 일치한다.
- 특정 자료형들이 메모리 공간 상에서 연속적으로 이루어져 있다.
- immutable하다.
- 인덱스로 해당 원소에 접근할 수 있으며, 인덱스를 알고 있다면 O(1)의 시간 복잡도로 원소에 접근이 가능하다. 즉, Random Access가 가능하다.
- 삭제 또는 삽입 과정에서는 해당 원소에 접근하여 작업을 완료한 뒤, shift해줘야 하므로 비용이 발생한다. O(n)
- 메모리 공간 활용에 제약이 있다.

### LinkedList

- 데이터 검색 시 처음 노드부터 순회해야 한다. 이유는 논리적 저장 순서와 물리적 저장 순서가 다르기 때문이다. O(n)
- 메모리 공간 상에서 각 노드들이 연속적으로 이루어져 있지 않고 흩어져 있으며, 각각의 노드가 자신의 다음 노드의 위치를 알고 있는 형태이다.
- 각 노드들이 메모리 공간 상의 어디에 위치하는지는 각각의 노드들만 알고 있고, 사용자는 제일 첫 번째 노드의 위치만 알고 있는 상태이다.
- 어떤 원소를 삽입, 삭제 시 그 원소를 찾기 위해 O(n)의 시간이 발생하고 추가적으로 작업을 완료하는 시간까지 O(n)의 시간이 걸린다.
- 결국, LinkedList는 검색과 삽입, 삭제 과정 모두 O(n)의 시간 복잡도를 갖는다.

## 데이터 접근 속도
### Array
- 인덱스를 사용하여 빠르게 접근하므로 시간 복잡도는 O(1)이다.
- Random Access가 가능하다.

### LinkedList
- 특정 원소에 접근하기 위해서는 처음부터 순차적으로 검색하기 때문에 시간 복잡도는 O(N)이다.

## 데이터 삽입 속도

### Array
- 데이터를 중간이나 맨 앞에 삽입할 경우, 이후의 데이터를 Shift해야 하므로 추가 과정과 시간이 소요된다.
- 따라서 데이터가 많은 경우, 비효율적이다.
- O(N)의 시간이 걸린다.

### LinkedList
- 중간 삽입 없이 맨 앞과 맨 뒤에만 삽입한다면 O(1)의 시간 복잡도를 갖는다.
- 그렇지 않다면 삽입할 위치를 찾고(O(N))과 삽입 연산을 진행하기 때문에 O(N)의 시간 복잡도를 갖는다.
- 그럼에도 불구하고 Array보다 빠른 성능을 갖는다.

Array의 경우, 데이터를 삽입하여 모든 공간이 꽉 차게 되면 새로운 메모리 공간을 할당받아 옮겨야 하지만, LinkedList를 그럴 필요가 없다. 추가할 때마다 동적으로 메모리 공간을 할당받는다.

## 데이터 삭제 속도
### Array
- 데이터 삭제의 경우, 그 위치의 데이터를 삭제한 후 전체적으로 Shift해줘야 하기 때문에 O(N)의 시간 복잡도를 갖는다.

### LinkedList
- 삭제할 원소를 찾기 위해 O(N)의 시간 복잡도를 갖고 삭제한다. 하지만, Array보다 빠르게 삭제 연산을 수행한다.

## 메모리 할당
### Array
- 메모리에는 Array가 선언되자 마자 Compile time에 할당되어 진다.
- 정적 메모리 할당이라고 한다.

### LinkedList
- 메모리는 새로운 Node가 추가될 때 runtime에 할당되어 진다.
- 동적 메모리 할당이라고 한다.

## 결론
- 삽입과 삭제가 빈번하게 일어난다면 LinkedList를 사용하는 것이 좋다.
- 데이터에 접근하는 것이 빈번하게 일어난다면 Array를 사용하는 것이 좋다.

---
## Dynamic Array vs LinkedList

자료구조에 해당하는 파트이지만, 자바를 기반으로 설명을 진행했다.

그러다보니 Collection에서 사용하는 네이밍을 따라 ArrayList라고 표기를 했다.

필자의 글을 보고 있던 분의 조언으로 Dynamic Array로 네이밍을 변경한다.

- Java : ArrayList
- C++ : Vector

기본적이면서도 면접 질문에 빠지지 않고 등장하는 단골 질문이다.

그래서 정리하려 한다.


- Dynamic Array(ArrayList)
    - 이름처럼 내부적으로 배열을 사용하여 데이터를 관리한다.
    - 인덱스를 가지고 있어 데이터 검색에 적합하고 속도가 빠르다.
        - 시간 복잡도 : O(1)
    - 데이터의 삽입, 삭제 시 해당 데이터를 제외한 모든 데이터를 임시 배열을 생성해 복사하므로 삽입, 삭제가 빈번할 경우 속도가 느리며 부적합하다.
        - 시간 복잡도 : O(n)
    - 동기화를 지원하지 않아 Vector보다 빠르다.



- LinkedList
    - 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있으면 된다.
    - 데이터 검색 시에는 처음부터 노드를 순회하기 때문에 오래 걸리며 성능상 좋지 않다.
        - 시간 복잡도 : O(n)
    - 데이터의 삽입, 삭제시 불필요한 데이터의 복사가 없어 데이터의 삽입, 삭제 시 유리하다.
        - 시간 복잡도 : O(1)
        - 하지만, 경우에 따라서 다르기도 하다.
        - 왜냐하면 삽입, 삭제를 하기 위한 노드를 찾기 위해서는 결국 O(n)이 걸리고 삽입, 삭제를 위한 시간 복잡도까지 계산하면 결국 O(n)이 걸린다.
        - 만약, 중간 요소의 삽입, 삭제가 없고 맨 앞과 뒤 요소의 삽입, 삭제만 한다면 O(1)이 걸린다. 그렇지 않으면 O(n).



따라서 데이터의 검색이 주가 되는 경우에는 Dynamic Array(ArrayList)를 사용하는 게 좋다.

데이터의 삽입, 삭제가 빈번하다면 Dynamic Array(ArrayList)보다는 LinkedList를 사용하는 편이 낫다.