---
layout: page
title: Part 1-1 좋은 코드란 무엇일까?
description: >
  좋은 코드란 무엇일까?
hide_description: true
sitemap: false
---

## 1. 좋은 코드란 무엇일까?

---
좋은 코드라는 말은 누구나 생각하기 나름이긴 하지만 전형적인 기본 베이스가 존재 한다.

- 읽기좋은 코드
- 리팩토링이 쉬운 코드

읽기 좋은 코드란 본인이 읽기 편한 코드라기보다는 타인이 분석 또는 리뷰를 할 때 한눈에 알아 채기 쉬운 코드라고 생각한다. 하지만 읽기 좋다고 해서 무조건 리팩토링까지 쉽다는 것은 아니다.

물론 코드가 효율적으로 잘 짜여진다면 리팩토링이 쉬울수도 있지만 읽기 좋은것과 리팩토링이 쉬운 그 사이 어딘가를 적절히 잘 배율하는 코딩이 좋은 코딩이라고 생각한다.

그러면 좋은 코드는 어떤 유형이 있을까?

### 1. 코드는 잘게 쪼개자

---
```java
public static void resultStatic(User user) {
        System.out.println(CommonMessage.RESULT_STATIC);
        System.out.println(CommonMessage.HYPHEN);

        resultWinningStatic(user);
        resultProfit(user);
    }
```

위 코드를 보면 `resultWinningStatic` 과 `resultProfit`을 함수로 나눠서 호출하는 모습을 볼 수 있다.
이처럼 각각의 기능들을 잘게 쪼개어 `resultWinningStatic`은 결과 출력 `resultProfit` 은 순이익 출력 역할을 부여하여 가독성을 높일 수 있다.

### 2. 함수는 하나의 일만 하도록 구성하자!

---
만약 위의 코드에서 `resultWinningStatic`, `resultProfit`를 합친다면  `resultWinningStaticAndProfit` 라고 함수명을 지을 수 있다.

하지만 `resultWinningStaticAndProfit`함수는 결과 출력과 수익률출력 두가지를 하고 있다.

해당 함수로 작성하면, 단점은 크게 두가지가 있을 수 있다.

1. 테스트 코드 작성이 어려워진다. (테스트 코드에서 하나의 기능만을 테스트 할 수 없다.)
2. 디버깅이 어려워진다. 해당 함수에서 에러가 발생한다면 과연 결과출력과 수익률출력중 어디에서 에러난지를 정확히 알 수 없다.

### 3. 객체는 상태와 행동으로 구성해야 한다!

---
SOLID 원칙중 SRP 라고 들어보았나 ?

```plaintext
SRP란 ?
객체 지향 프로그래밍에서 단일 책임 원칙이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 
클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다. -위키백과-
```

JAVA로 처음 객체지향 프로그래밍을 접할 때 많이 예시로 드는 자동차로 설명해보겠다. 엑셀은 자동차 전진 이라는 함수를 가질수 있다.

만약 엑셀 객체에 메소드로 자동차 정지 라는 매소드를 만든다면 이는 SRP를 위반하는 것이다. 자동차 정지는 브레이크 라는 객체의 역할이므로 책임이 엑셀에게 간 것을 볼 수있다.

이와같이 객체는 상태(엑셀), 행동(자동차 전진) 과 같이 구성될 수 있으며, 이를 객체의 특성에 맞게 잘 분리하면 추후 요구사항이 변경되거나 기능이 추가되어도 기존에 존재하 는 객체를 사용해 비지니스 로직을 수정하지 않고도 변경된 요구사항에 자연스럽게 대처 할 수 있다.

## 2. Object Oriented Programming

---
객체 지향 프로그래밍은 너무나 뜻이 방대하기 때문에 살짝 이해하기 쉽게 요약 해보려고 한다!

객체 지향 프로그래밍 이전의 프로그래밍 패러다임을 살펴보면, 중심이 컴퓨터에 있었다. 컴퓨터가 
사고하는대로 프로그래밍을 하는 것이다. 하지만 객체지향 프로그래밍이란 인간 중심적 프로그래밍 
패러다임이라고 할 수 있다. 즉, 현실 세계를 프로그래밍으로 옮겨와 프로그래밍하는 것을 말한다. 
현실 세계의 사물들을 객체라고 보고 그 객체로부터 개발하고자 하는 애플리케이션에 필요한 특징들을 
뽑아와 프로그래밍 하는 것이다. 이것을 추상화라한다.

OOP 로 코드를 작성하면 이미 작성한 코드에 대한 재사용성이 높다. 자주 사용되는 로직을 라이브러리로
만들어두면 계속해서 사용할 수 있으며 그 신뢰성을 확보 할 수 있다. 또한 라이브러리를 각종 
예외상황에 맞게 잘 만들어두면 개발자가 사소한 실수를 하더라도 그 에러를 컴파일 단계에서 잡아낼 수 
있으므로 버그 발생이 줄어든다. 또한 내부적으로 어떻게 동작하는지 몰라도 개발자는 라이브러리가 
제공하는 기능들을 사용할 수 있기 때문에 생산성이 높아지게 된다. 객체 단위로 코드가 나눠져 작성되기
때문에 디버깅이 쉽고 유지보수에 용이하다. 또한 데이터 모델링을 할 때 객체와 매핑하는 것이 수월하기
때문에 요구사항을 보다 명확하게 파악하여 프로그래밍 할 수 있다.

객체 간의 정보 교환이 모두 메시지 교환을 통해 일어나므로 실행 시스템에 많은 overhead 가 
발생하게 된다. 하지만 이것은 하드웨어의 발전으로 많은 부분 보완되었다. 객체 지향 프로그래밍의
치명적인 단점은 함수형 프로그래밍 패러다임의 등장 배경을 통해서 알 수 있다. 
바로 객체가 상태를 갖는다는 것이다. 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를
갖게 되어 애플리케이션 내부에서 버그를 발생시킨다는 것이다. 이러한 이유로 함수형 패러다임이 
주목받고 있다.


### SOLID 원칙
1. SRP(Single Responsibility Principle) : 단일 책임 원칙
클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙
확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.
4. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.
5. DIP(Dependency Inversion Principle) : 의존 역전 원칙
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.

